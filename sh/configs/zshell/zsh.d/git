  #!/bin/zsh
#-------------------------------------------------------
#   Overview
#-------------------------------------------------------
#   This file serves two main purposes:
#     1. Implements git branch output in the zsh prompt.
#        This output is cached (so we only update it
#        when the PWD is changed or when a git operation
#        is executed).
#     2. Acts as a collection of my personal git
#        functions.  Hooray!
#
#   In order for #1 to work, you have to allow zsh to
#   substitute stuff in the prompt.  Then you can
#   execute "get_git_prompt_info" (the main prompt
#   function):
#     setopt prompt_subst
#     RPROMPT="$(get_git_prompt_info)"

########################################################
#-------------- 1. GIT BRANCH PROMPT ------------------#
########################################################
#-------------------------------------------------------
#   Environment Variables
#-------------------------------------------------------
#   These vars hold various bits of git info.  They are
#   crucial to the whole caching thing working.
#-------------------------------------------------------
__ZSH_GIT_DIR=
__ZSH_GIT_BRANCH=
__ZSH_GIT_STATE=
__ZSH_GIT_TS=0
__ZSH_GIT_VARS_INVALID=1

#-------------------------------------------------------
#   get_git_prompt_info()
#-------------------------------------------------------
#   This function returns info on the current git
#   branch.  It takes a string with printf-like 
#   arguments:
#     '%P'     path to top of repository
#     '%p'     path to top of repository, with s/$HOME/~/
#     '%b'     current branch
#     '%s'     state of rebase/merge/bisect/am
#     '%%'     a '%' character
#   Providing no arguments is equivalent to "%p %b %s"
#-------------------------------------------------------
get_git_prompt_info() {
  zsh_git_compute_vars $__ZSH_GIT_VARS_INVALID
  [[ -n "$__ZSH_GIT_DIR" ]] || return

  local def fmt res
  def='%p %b %s'
  fmt=$@
  res=${fmt:-$def}
  res=${res//\%P/$__ZSH_GIT_FULL_DIR}
  res=${res//\%p/$__ZSH_GIT_DIR}
  res=${res//\%b/$__ZSH_GIT_BRANCH}

  local state="$__ZSH_GIT_STATE"
  if [[ -n "$state" ]] ; then
    state="$state "

  # NOTE: This code take a long time to execute on large repos,
  # but can show if the repo is dirty or not.  It cannot be 
  # cached because it's too hard to figure out which commands
  # change this state.  Enable it if you work on only small
  # repositories.
  elif ! git diff --quiet || [[ -n $(git ls-files --others --exclude-standard) ]] ; then
    state=":dirty"
  fi
  
  res=${res//\%s/$state}
  res=${res//\%%/%}
  echo -n "${res}"
}

#-------------------------------------------------------
#   new_parse_git_branch()
#-------------------------------------------------------
#   Big function that ultimate determines the state of
#   the current git branch.  
#-------------------------------------------------------
new_parse_git_branch() {
  local force=$1
  local git_dir branch
  psvar=()
  git_dir=$(git rev-parse --git-dir 2> /dev/null)
  if [[ -z "$git_dir" ]] ; then
    __ZSH_GIT_DIR=
    return
  fi

  # Linux-GNU OS setups use different stat options than 
  # OS X or Cygwin.  Unfortunately, we have to check for
  # both to ensure cross-platform compatibility.
  if [[ "$os" == "linux-gnu" ]]; then
    local new_stamp=$(stat --printf='%Y' "$git_dir/HEAD")
  else
    local new_stamp=$(stat -f '%m' "$git_dir/HEAD")
  fi

  [[ "$force" == "0" && "$__ZSH_GIT_TS" == "$new_stamp" ]] && return

  # rewritten by Thomas Ritz <thomas(at)galaxy-ritz(dot)de>
  __ZSH_GIT_STATE=
  if [[ -d "$git_dir/rebase-apply" ]] ; then
    if [[ -f "$git_dir/rebase-apply/rebasing" ]] ; then
      __ZSH_GIT_STATE="rebase"
    elif [[ -f "$git_dir/rebase-apply/applying" ]] ; then
      __ZSH_GIT_STATE="am"
    else
      __ZSH_GIT_STATE="am/rebase"
    fi
    branch="$(git symbolic-ref HEAD 2>/dev/null)"
  elif [[ -f "$git_dir/rebase-merge/interactive" ]] ; then
    __ZSH_GIT_STATE="rebase -i"
    branch="$(cat "$git_dir/rebase-merge/head-name")"
  elif [[ -d "$git_dir/rebase-merge" ]] ; then           
    __ZSH_GIT_STATE="rebase -m"
    branch="$(cat "$git_dir/rebase-merge/head-name")"
  elif [[ -f "$git_dir/MERGE_HEAD" ]] ; then             
    __ZSH_GIT_STATE="merge"
    branch="$(git symbolic-ref HEAD 2>/dev/null)"
  else                                             
    [[ -f "$git_dir/BISECT_LOG" ]] && __ZSH_GIT_STATE="bisect"
    branch="$(git symbolic-ref HEAD 2>/dev/null)" || \
      branch="$(git describe --exact-match HEAD 2>/dev/null)" || \
      branch="$(cut -c1-7 "$git_dir/HEAD")..."
  fi                                              

  # OS X and Cygwin don't have the equivalent of
  # Linux-GNU's readlink -f command.  Therefore,
  # in spectacularly crappy fashion, we use a
  # Python script to accomplish the same thing.
  if [[ "$os" == "linux-gnu" ]]; then
    __ZSH_GIT_FULL_DIR=$(readlink -f ${git_dir:h})
  else
    __ZSH_GIT_FULL_DIR=$(realpath ${git_dir:h})
  fi

  __ZSH_GIT_DIR="${__ZSH_GIT_FULL_DIR/$HOME/~}"
  __ZSH_GIT_BRANCH="${branch#refs/heads/}"
  __ZSH_GIT_TS=$new_stamp
}

#-------------------------------------------------------
#   parse_git_branch()
#-------------------------------------------------------
#   Carefully formats the branch information in the
#   given git repository.
#-------------------------------------------------------
parse_git_branch() {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1) -- /'
}

#-------------------------------------------------------
#   zsh_git_chpwd_update_vars()
#-------------------------------------------------------
#   Computes git vars as soon as the PWD is changed
#-------------------------------------------------------
zsh_git_chpwd_update_vars() {
  zsh_git_compute_vars 1
}

#-------------------------------------------------------
#   zsh_git_compute_vars()
#-------------------------------------------------------
#   Computes git vars and "cleans" the prompt status 
#-------------------------------------------------------
zsh_git_compute_vars() {
  new_parse_git_branch $1
  __ZSH_GIT_VARS_INVALID=0
}

#-------------------------------------------------------
#   zsh_git_invalidate_vars()
#-------------------------------------------------------
#   Wrapper function for setting when git variables
#   need to be updated. 
#-------------------------------------------------------
zsh_git_invalidate_vars() {
  __ZSH_GIT_VARS_INVALID=1
}

#-------------------------------------------------------
#   zsh_git_preexec_update_vars()
#-------------------------------------------------------
#   Computes git vars when a git command is run
#-------------------------------------------------------
zsh_git_preexec_update_vars() {
  case "$(history $HISTCMD)" in 
    *git*)  zsh_git_invalidate_vars ;;
    *)      [[ "$__ZSH_GIT_VARS_INVALID" == '0' ]] && return ;;
  esac
  zsh_git_compute_vars 1
}

#-------------------------------------------------------
#   Update zsh's preexec and chpwd functions to use
#   our git-related ones
#-------------------------------------------------------
preexec_functions+='zsh_git_preexec_update_vars'
chpwd_functions+='zsh_git_chpwd_update_vars'


#-------------------------------------------------------
#   Compute the git vars for the first time (when zsh
#   loads)
#-------------------------------------------------------
zsh_git_compute_vars

########################################################
#--------------- 2. MY GIT FUNCTIONS ------------------#
########################################################
#-------------------------------------------------------
#   __git_exec_file_move()
#-------------------------------------------------------
#   Generic function that most of my git "moving"
#   functions extend.  Basically ties git execution to
#   a branch and associated origin.
#-------------------------------------------------------
__git_exec_file_move()
{
  local remote=""
  local branch=$(get_git_prompt_info "%b")
  local command=$1
  shift

  if [ -z "$branch" ]; then
    return 1
  fi

  while [ "$1" != "" ]; do
    case $1 in
      -b | --branch )         
        branch=$2
        shift
        ;;
      -h | --help )
        echo "Usage: git ${command} [[-b branch ] | [-h]]"
        return
        ;;
      * )                     
        ;;
    esac
    shift
  done

  if [ -z "$branch" ]; then
    echo "You provided the -b flag, but did not specify a branch"
    return
  fi

  remote=$(git config branch.${branch}.remote)
  if [ -z "$remote" ]; then
    echo "There is no matching remote for branch '${branch}' in your .git/config file.  Defaulting to remote 'origin'."
    remote="origin"
  fi

  git $command $remote $branch
}

#--------------------------------------------------
#    Defines a "branch" block in a .git/config file
#--------------------------------------------------
gconfbr()
{
  if [ "$#" -ne 2 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    echo "Usage: gconfbr [remote] [branch]" >&2
    return 1
  fi

  local is_git=$(get_git_prompt_info "%b")
  if [ -n "$is_git" ]; then
    cat >> .git/config <<BLOCK
[branch "${2}"]
        remote = ${1}
        merge = refs/heads/${2}
BLOCK
  fi
}

#--------------------------------------------------
#    Fetches, diffs, and prompts user to merge
#    (using current branch and it's associated 
#    remote, if present)
#--------------------------------------------------
getch()
{
  __git_exec_file_move fetch "$@"
  git diff -R FETCH_HEAD
  
  local needs_merge=$(git diff -R FETCH_HEAD | grep diff 2> /dev/null)
  if [ -n "$needs_merge" ]; then
    echo -n 'Do you want to merge? (y/n) [n]: '
    read -e merge_option
    if [ "$merge_option" == "y" ]; then
      git merge FETCH_HEAD
    fi
  fi
}

#--------------------------------------------------
#    Easy wrapper for git clone
#--------------------------------------------------
glone()
{
  if [ "$#" -ne 2 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    echo "Usage: glone [host] [repo-name]" >&2
    return 1
  fi
 
  git clone git@${1}:${2}
}

#--------------------------------------------------
#    Does a git pp on the current branch (using
#    it's associated remote, if present)
#--------------------------------------------------
gpp()
{
  __git_exec_file_move pp "$@"
}

#--------------------------------------------------
#    Does a git pull on the current branch (using
#    it's associated remote, if present)
#--------------------------------------------------
gull()
{
  __git_exec_file_move pull "$@"
}

#--------------------------------------------------
#    Does a git push on the current branch (using
#    it's associated remote, if present)
#--------------------------------------------------
gush()
{
  __git_exec_file_move push "$@"
}
